jq -r '
  # CSVヘッダー行を定義
  ["ReservationId", "InstanceId", "InstanceType", "State", "PrivateIpAddress", "PublicIpAddress", "LaunchTime", "AvailabilityZone", "ImageId", "KeyName", "VpcId", "SubnetId", "SecurityGroupNames", "TagName", "MonitoringState", "RootDeviceType", "EbsOptimized", "VirtualizationType", "Architecture", "IamInstanceProfileArn"],
  # データ行を処理
  (.Reservations[] as $r | $r.Instances[] as $i | [
    $r.ReservationId,
    $i.InstanceId,
    $i.InstanceType,
    $i.State.Name,
    $i.PrivateIpAddress,
    $i.PublicIpAddress // "",  # PublicIpAddressが存在しない場合は空文字
    $i.LaunchTime,
    $i.Placement.AvailabilityZone,
    $i.ImageId,
    $i.KeyName // "",          # KeyNameが存在しない場合は空文字
    $i.VpcId // "",            # VpcIdが存在しない場合は空文字
    $i.SubnetId // "",        # SubnetIdが存在しない場合は空文字
    ([$i.SecurityGroups[]?.GroupName] | join(",")) // "", # SecurityGroupのGroupNameをカンマ区切りで結合、存在しない/空の場合は空文字
    ($i.Tags[]? | select(.Key=="Name") | .Value) // "",    # Keyが"Name"であるタグのValueを取得、存在しない場合は空文字
    $i.Monitoring.State // "", # Monitoring.Stateが存在しない場合は空文字
    $i.RootDeviceType // "",   # RootDeviceTypeが存在しない場合は空文字
    $i.EbsOptimized,           # EbsOptimized (ブール値は@csvが適切に処理)
    $i.VirtualizationType // "",# VirtualizationTypeが存在しない場合は空文字
    $i.Architecture // "",     # Architectureが存在しない場合は空文字
    ($i.IamInstanceProfile.Arn // "") # IamInstanceProfile.Arnが存在しない場合は空文字
  ])
  | @csv # 配列をCSV形式の文字列に変換
' your_file.json

# =============================================================================
# スクリプトのパラメータ定義 (要件3対応)
# =============================================================================
param(
    [Parameter(Mandatory=$false, HelpMessage="処理対象のJSONファイルまたはフォルダのパスを指定します。未指定の場合はinput_jsonフォルダ全体を処理します。")]
    [string]$InputPath
)

# =============================================================================
# 初期設定
# =============================================================================
try {
    # スクリプトが置かれているディレクトリを基準に各パスを設定
    $scriptRoot = $PSScriptRoot
    $jqPath = Join-Path $scriptRoot "jq.exe"
    $inputDir = Join-Path $scriptRoot "input_json"
    $jqQueryDir = Join-Path $scriptRoot "jq_query"
    $outputDir = Join-Path $scriptRoot "output_csv"

    # 必須ファイルの存在チェック
    if (-not (Test-Path -Path $jqPath -PathType Leaf)) { throw "jq.exe が見つかりません: $jqPath" }
    if (-not (Test-Path -Path $inputDir -PathType Container)) { throw "入力フォルダが見つかりません: $inputDir" }
    if (-not (Test-Path -Path $jqQueryDir -PathType Container)) { throw "JQクエリフォルダが見つかりません: $jqQueryDir" }

    # 出力フォルダがなければ作成
    if (-not (Test-Path -Path $outputDir -PathType Container)) {
        Write-Host "INFO: 出力フォルダを作成します: $outputDir"
        New-Item -Path $outputDir -ItemType Directory | Out-Null
    }

    # BOMなしUTF-8のエンコーディング設定
    $utf8WithoutBom = New-Object System.Text.UTF8Encoding($false)

    # =============================================================================
    # 設定 (要件1, 2対応)
    # =============================================================================

    # 要件1: JSONの最初のキーと使用するjqクエリのマッピング
    # キー名 = "使用するjqファイル名"
    $jqQueryMap = @{
        "SecurityGroupRules" = "aws-security-group-rules.jq"
        "Users"              = "aws-iam-users.jq"
        "Volumes"            = "aws-ec2-volumes.jq"
        # 他のキーとクエリのマッピングをここに追加
    }

    # 要件2: マージ処理の定義
    $mergeTasks = @(
        @{
            OutputCsv  = "merged-BBB-CCC.csv"
            InputFiles = @("BBB.json", "CCC.json")
            JqQuery    = "merge-BBB-CCC.jq"
        }
    )

    # =============================================================================
    # メイン処理
    # =============================================================================

    # ---
    # 1. 処理対象のJSONファイルリストを取得 (要件3対応)
    # ---
    $targetFiles = @()
    if ([string]::IsNullOrEmpty($InputPath)) {
        Write-Host "INFO: 処理対象の指定がないため、'$($inputDir)' 内のすべてのJSONファイルを処理します。"
        $targetFiles = Get-ChildItem -Path $inputDir -Filter "*.json" -Recurse
    } elseif (Test-Path -Path $InputPath) {
        if ((Get-Item $InputPath) -is [System.IO.DirectoryInfo]) {
            Write-Host "INFO: 指定されたフォルダ内のJSONファイルを処理します: $InputPath"
            $targetFiles = Get-ChildItem -Path $InputPath -Filter "*.json" -Recurse
        } else {
            Write-Host "INFO: 指定された単一のJSONファイルを処理します: $InputPath"
            $targetFiles = Get-Item -Path $InputPath
        }
    } else {
        throw "指定されたパスが見つかりません: $InputPath"
    }

    if ($null -eq $targetFiles) {
        Write-Warning "処理対象のJSONファイルが見つかりませんでした。"
        exit
    }
    
    $processedFiles = [System.Collections.Generic.List[string]]::new()

    # ---
    # 2. マージ処理 (要件2対応)
    # ---
    if ([string]::IsNullOrEmpty($InputPath)) {
        Write-Host "--------------------------------------------------"
        Write-Host "マージ処理を開始します..."
        foreach ($task in $mergeTasks) {
            $inputJsonPaths = @()
            $allFilesFound = $true
            
            foreach ($file in $task.InputFiles) {
                $found = Get-ChildItem -Path $inputDir -Filter $file -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($found) {
                    $inputJsonPaths += $found.FullName
                    $processedFiles.Add($found.FullName)
                } else {
                    Write-Warning "マージ対象ファイルが見つかりません: $file"
                    $allFilesFound = $false
                    break
                }
            }

            if (-not $allFilesFound) { continue }

            Write-Host "以下のファイルをマージして'$($task.OutputCsv)'を作成します: $($task.InputFiles -join ', ')"
            $jqQueryFile = Join-Path $jqQueryDir $task.JqQuery
            $csvOutputFile = Join-Path $outputDir $task.OutputCsv
            
            $inputJsonPaths | ForEach-Object {
                 $content = Get-Content -Path $_ -Raw -Encoding utf8
                 [System.IO.File]::WriteAllText($_, $content, $utf8WithoutBom)
            }

            try {
                $jqArgs = @('-s', '-r', '-f', $jqQueryFile) + $inputJsonPaths
                & $jqPath $jqArgs | Set-Content -Path $csvOutputFile -Encoding utf8
                Write-Host "マージCSVファイルを作成しました: $csvOutputFile"
            } catch {
                Write-Warning "マージ処理中にエラーが発生しました: $($_.Exception.Message)"
            }
        }
    }

    # ---
    # 3. 個別ファイル処理
    # ---
    Write-Host "--------------------------------------------------"
    Write-Host "個別ファイルの処理を開始します..."
    foreach ($jsonFile in $targetFiles) {
        if ($processedFiles.Contains($jsonFile.FullName)) {
            Write-Host "INFO: マージ処理済みのためスキップします: $($jsonFile.Name)"
            continue
        }

        Write-Host "--- 処理開始: $($jsonFile.FullName) ---"
        try {
            $content = Get-Content -Path $jsonFile.FullName -Raw -Encoding utf8
            [System.IO.File]::WriteAllText($jsonFile.FullName, $content, $utf8WithoutBom)
            Write-Host "[1/2] BOMなしUTF-8へ変換完了"

            $firstKey = (& $jqPath -r "keys[0]" $jsonFile.FullName 2>$null).Trim()

            if ([string]::IsNullOrEmpty($firstKey) -or -not $jqQueryMap.ContainsKey($firstKey)) {
                throw "対応するJQクエリがマッピングに存在しません。JSONのキーを確認してください: (キー: '$firstKey')"
            }

            # ★★★★★ 変更点 ★★★★★
            # 曖昧なフォールバックロジックを廃止し、キーマッピングに基づく単一のロジックに修正
            
            # input_jsonからの相対パスを取得
            $relativeSubDir = $jsonFile.Directory.FullName.Replace($inputDir, "").TrimStart("\")
            
            # 対応するjqファイルのパスを構築
            $jqQueryFileName = $jqQueryMap[$firstKey]
            $jqQueryFile = Join-Path $jqQueryDir $relativeSubDir $jqQueryFileName
            
            # jqファイルが指定されたパスに存在するか、厳密にチェック
            if (-not (Test-Path -Path $jqQueryFile -PathType Leaf)) {
                throw "対応するJQファイルが見つかりません。次のパスを確認してください: $jqQueryFile"
            }
            # ★★★★★ 変更ここまで ★★★★★

            # 出力先のサブフォルダパスを構築
            $outputSubDir = Join-Path $outputDir $relativeSubDir
            if (-not (Test-Path $outputSubDir)) {
                 New-Item -Path $outputSubDir -ItemType Directory | Out-Null
            }
            $csvOutputFile = Join-Path $outputSubDir ($jsonFile.BaseName + ".csv")

            # jqコマンドを実行してCSVに変換
            $jqArgs = @('-r', '-f', $jqQueryFile, $jsonFile.FullName)
            & $jqPath $jqArgs | Set-Content -Path $csvOutputFile -Encoding utf8
            Write-Host "[2/2] CSVファイルを作成しました: $csvOutputFile"

        } catch {
            Write-Warning "エラーが発生しました: $($_.Exception.Message)"
            continue
        }
    }

    Write-Host "--------------------------------------------------"
    Write-Host "全ての処理が完了しました。"
}
catch {
    Write-Error "致命的なエラーが発生しました: $($_.Exception.Message)"
}

# =============================================================================
# 初期設定
# =============================================================================
try {
    # スクリプトが置かれているディレクトリを基準に各パスを設定
    $scriptRoot = $PSScriptRoot
    $jqPath = $scriptRoot + "\jq.exe"
    $inputDir = $scriptRoot + "\input_json"
    $jqQueryDir = $scriptRoot + "\jq_query"
    $outputDir = $scriptRoot + "\output_csv"

    # 必須ファイルの存在チェック
    if (-not (Test-Path -Path $jqPath -PathType Leaf)) { throw "jq.exe が見つかりません: $jqPath" }
    if (-not (Test-Path -Path $inputDir -PathType Container)) { throw "入力フォルダが見つかりません: $inputDir" }
    if (-not (Test-Path -Path $jqQueryDir -PathType Container)) { throw "JQクエリフォルダが見つかりません: $jqQueryDir" }

    # 出力フォルダがなければ作成
    if (-not (Test-Path -Path $outputDir -PathType Container)) {
        Write-Host "INFO: 出力フォルダを作成します: $outputDir"
        New-Item -Path $outputDir -ItemType Directory | Out-Null
    }

    # =============================================================================
    # ★★★ 設定項目 ★★★
    # JSONのキーと、それに対応する「jqファイル」および「出力ファイル」のマッピング
    # =============================================================================
    $fileMapping = @{
        # "JSONの最初のキー" = @{ JqFile = "使用するjqファイル名"; OutputFileBase = "出力ファイル名のベース" }
        "Reservations"           = @{ JqFile = "instances.jq";                OutputFileBase = "instances" }
        "LoadBalancers"          = @{ JqFile = "LoadBalancers.jq";            OutputFileBase = "LoadBalancers" }
        "SecurityGroups"         = @{ JqFile = "SecurityGroups.jq";           OutputFileBase = "SecurityGroups" }
        "VpcEndpointConnections" = @{ JqFile = "VpcEndpointConnections.jq";   OutputFileBase = "VpcEndpointConnections" }
        "AllowedPrincipals"      = @{ JqFile = "AllowedPrincipals.jq";        OutputFileBase = "AllowedPrincipals" }
        "Directories"            = @{ JqFile = "Directories.jq";              OutputFileBase = "Directories" }
        "Workspaces"             = @{ JqFile = "Workspaces.jq";               OutputFileBase = "Workspaces" }
        # 他のキーとファイルの対応をここに追加
    }

    # 出力ファイル名に使用する日付文字列
    $dateString = Get-Date -Format "yyyyMMdd"

    # =============================================================================
    # メイン処理
    # =============================================================================
    $jsonFiles = Get-ChildItem -Path $inputDir -Filter "*.json" -Recurse

    if ($null -eq $jsonFiles) {
        Write-Warning "処理対象のJSONファイルが見つかりませんでした。"
        exit
    }

    $utf8WithoutBom = New-Object System.Text.UTF8Encoding($false)

    foreach ($jsonFile in $jsonFiles) {
        Write-Host "--------------------------------------------------"
        Write-Host "処理開始: $($jsonFile.FullName)"

        try {
            # ---
            # 1. BOMなしUTF-8へ変換
            # ---
            $content = Get-Content -Path $jsonFile.FullName -Raw -Encoding utf8
            [System.IO.File]::WriteAllText($jsonFile.FullName, $content, $utf8WithoutBom)
            Write-Host "[1/3] BOMなしUTF-8へ変換完了"

            # ---
            # 2. JSONキーに基づき、使用するファイル名を決定
            # ---
            $firstKey = (& $jqPath -r "keys[0]" $jsonFile.FullName 2>$null).Trim()

            if (-not $fileMapping.ContainsKey($firstKey)) {
                throw "JSONキー '$firstKey' に対応する定義がマッピングに見つかりません。スクリプト内の`$fileMapping`を確認してください。"
            }

            # マッピングから対応するファイル名を取得
            $mappingInfo = $fileMapping[$firstKey]
            $jqFileName = $mappingInfo.JqFile
            $outputFileBaseName = $mappingInfo.OutputFileBase

            # input_jsonからの相対パスを取得
            $relativeSubDir = $jsonFile.Directory.FullName.Replace($inputDir, "").TrimStart("\")

            # 使用するjqファイルのフルパスを構築
            $jqQueryFile = $jqQueryDir + "\" + $relativeSubDir + "\" + $jqFileName
            
            # 出力するCSVファイルのフルパスを構築
            $csvFileName = "${dateString}_${outputFileBaseName}.csv"
            $outputSubDir = $outputDir + "\" + $relativeSubDir
            $csvOutputFile = $outputSubDir + "\" + $csvFileName

            Write-Host "[2/3] JQクエリ '$jqQueryFile' を使用し、'$csvOutputFile' に出力します。"

            # ---
            # 3. jqでCSVに変換し、ファイルに保存
            # ---
            if (-not (Test-Path -Path $jqQueryFile -PathType Leaf)) {
                throw "JQクエリファイルが見つかりません: $jqQueryFile"
            }
            if (-not (Test-Path -Path $outputSubDir -PathType Container)) {
                New-Item -Path $outputSubDir -ItemType Directory | Out-Null
            }

            $jqArgs = @('-r', '-f', $jqQueryFile, $jsonFile.FullName)
            
            # jqを実行し、結果を変数に格納
            $jqOutput = & $jqPath $jqArgs 2>&1

            # jqの実行結果を確認
            if ($LASTEXITCODE -ne 0) {
                throw "jq.exeがエラーを返しました: $jqOutput"
            }

            # 成功した場合のみファイルに書き込み
            $jqOutput | Set-Content -Path $csvOutputFile -Encoding utf8
            
            Write-Host "[3/3] CSVファイルの作成が完了しました。"
        }
        catch {
            Write-Warning "エラーが発生しました: $($_.Exception.Message)"
            continue # エラーが発生しても次のファイルの処理へ
        }
    }
    Write-Host "--------------------------------------------------"
    Write-Host "全ての処理が完了しました。"
}
catch {
    Write-Error "致命的なエラーが発生しました: $($_.Exception.Message)"
}

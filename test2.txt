# =============================================================================
# 初期設定
# =============================================================================
try {
    # スクリプトが置かれているディレクトリを基準に各パスを設定 (Join-Pathで堅牢化)
    $scriptRoot = $PSScriptRoot
    $jqPath = Join-Path $scriptRoot "jq.exe"
    $inputDir = Join-Path $scriptRoot "input_json"
    $jqQueryDir = Join-Path $scriptRoot "jq_query"
    $outputDir = Join-Path $scriptRoot "output_csv"

    # 必須ファイルの存在チェック
    if (-not (Test-Path -Path $jqPath -PathType Leaf)) { throw "jq.exe が見つかりません: $jqPath" }
    if (-not (Test-Path -Path $inputDir -PathType Container)) { throw "入力フォルダが見つかりません: $inputDir" }
    if (-not (Test-Path -Path $jqQueryDir -PathType Container)) { throw "JQクエリフォルダが見つかりません: $jqQueryDir" }

    # 出力フォルダがなければ作成
    if (-not (Test-Path -Path $outputDir -PathType Container)) {
        Write-Host "INFO: 出力フォルダを作成します: $outputDir"
        New-Item -Path $outputDir -ItemType Directory | Out-Null
    }

    # =============================================================================
    # ★★★ 新しい設定項目 ★★★
    # JSONのキーと、それに対応するJQファイル名のマッピング
    # =============================================================================
    $jqQueryMap = @{
        "SecurityGroupRules" = "aws-security-group-rules.jq"
        "Users"              = "aws-iam-users.jq"
        "Volumes"            = "aws-ec2-volumes.jq"
        # 他のキーと、それに対応するクエリファイル名をここに追加
    }


    # =============================================================================
    # メイン処理
    # =============================================================================

    # input_jsonフォルダ配下のすべてのjsonファイルを再帰的に取得
    $jsonFiles = Get-ChildItem -Path $inputDir -Filter "*.json" -Recurse

    if ($null -eq $jsonFiles) {
        Write-Warning "処理対象のJSONファイルが見つかりませんでした。"
        exit
    }

    # BOMなしUTF-8のエンコーディング設定
    $utf8WithoutBom = New-Object System.Text.UTF8Encoding($false)

    # 各JSONファイルに対して処理を実行
    foreach ($jsonFile in $jsonFiles) {
        
        Write-Host "--------------------------------------------------"
        Write-Host "処理開始: $($jsonFile.FullName)"

        try {
            # ---
            # 1. インプットファイルをBOMなしUTF-8に変換
            # ---
            $content = Get-Content -Path $jsonFile.FullName -Raw -Encoding utf8
            [System.IO.File]::WriteAllText($jsonFile.FullName, $content, $utf8WithoutBom)
            Write-Host "[1/3] BOMなしUTF-8へ変換完了"


            # ---
            # 2. jq.exeを用いて、使用するJQファイルを動的に決定
            # ---
            
            # jqを使ってJSONの最初のキーを取得
            $firstKey = (& $jqPath -r "keys[0]" $jsonFile.FullName 2>$null).Trim()

            # キーが取得できたか、マッピングに存在するかをチェック
            if ([string]::IsNullOrEmpty($firstKey) -or -not $jqQueryMap.ContainsKey($firstKey)) {
                throw "JSONのキー'$firstKey'に対応するJQファイルがマッピングに見つかりません。スクリプト内の`$jqQueryMap`を確認してください。"
            }
            
            # input_jsonからの相対的なサブディレクトリパスを取得
            $relativeSubDir = $jsonFile.Directory.FullName.Replace($inputDir, "").TrimStart("\")

            # マッピング定義とサブディレクトリから、使用するjqファイルのフルパスを構築
            $jqQueryFileName = $jqQueryMap[$firstKey]
            $jqQueryFile = Join-Path $jqQueryDir $relativeSubDir $jqQueryFileName

            # 最終的なjqファイルの存在をチェック
            if (-not (Test-Path -Path $jqQueryFile -PathType Leaf)) {
                throw "対応するJQファイルが見つかりません。次のパスを確認してください: $jqQueryFile"
            }
            Write-Host "[2/3] 使用するJQファイルを決定: $jqQueryFile"


            # ---
            # 3. jq.exeを用いてCSVに変換し、指定フォルダに保存
            # ---
            
            # 出力先のサブフォルダとファイルパスを構築
            $outputSubDir = Join-Path $outputDir $relativeSubDir
            $csvOutputFile = Join-Path $outputSubDir ($jsonFile.BaseName + ".csv")

            # 出力先のサブフォルダがなければ作成
            if (-not (Test-Path -Path $outputSubDir -PathType Container)) {
                New-Item -Path $outputSubDir -ItemType Directory | Out-Null
            }

            # jqコマンドの引数を配列として定義
            $jqArgs = @('-r', '-f', $jqQueryFile, $jsonFile.FullName)

            # jqコマンドを実行
            & $jqPath $jqArgs | Set-Content -Path $csvOutputFile -Encoding utf8

            # $LASTEXITCODE を使ったエラーチェックは、パイプライン(|)の後では信頼できないため、
            # Set-Contentが成功したことをもって成功とみなす
            
            Write-Host "[3/3] CSVファイルを作成しました: $csvOutputFile"
        }
        catch {
            # throwされたエラーメッセージをキャッチして表示
            Write-Warning "エラーが発生しました: $($_.Exception.Message)"
            continue # 次のファイルの処理へ
        }
    }
    Write-Host "--------------------------------------------------"
    Write-Host "全ての処理が完了しました。"
}
catch {
    # スクリプト全体で発生した致命的なエラーをキャッチ
    Write-Error "致命的なエラーが発生しました: $($_.Exception.Message)"
}
